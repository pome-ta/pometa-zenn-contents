---
title: "【制作編】#3: a-Shell(mini) アプリでアプリをつくる【Rubicon-ObjC】"
emoji: "🎁"
type: "tech"
topics: ["Python", "iOS", "objectivec", "ashell", "rubiconobjc"]
published: false
---

# はじめに

[a-Shell](https://holzschu.github.io/a-Shell_iOS/) で、[SF Symbols](https://developer.apple.com/jp/sf-symbols/) の一覧を出す簡単なアプリをつくります。


![image](https://github.com/user-attachments/assets/9bd5ebab-2e22-4f66-be66-fb31da505efb)

@[card](https://developer.apple.com/jp/sf-symbols/)

今まで紹介したパッケージライブラリを使い、端末内にある SF Symbols データの取り出し、表示までをハンズオン形式で実装していきます。

:::message
App Store へ公開はできません
:::

## 全 3 部構成の第 3 部です

この記事を含め、3 部構成で解説をします。コピペで動くようにしています:

- 【導入編】#1: a-Shell(mini) アプリでアプリをつくる【Rubicon-ObjC】

  - 1 ファイルのみの簡易な実装
  - a-Shell 実行の大まかな流れ

- 【準備編】#2: a-Shell(mini) アプリでアプリをつくる【Rubicon-ObjC】

  - アプリ制作のための環境整備
  - 1 ファイルだったコードを パッケージ へ分割
  - パッケージ内のコード説明


- 【制作編】#3: a-Shell(mini) アプリでアプリをつくる【Rubicon-ObjC】
  - (今回はここ)
  - Rubicon-ObjC を使った実装の流れ
  - Swift, Objective-C のコードを Rubicon-ObjC へ落とし込む方法

3 つの記事を通したコードは、GitHub で公開しています。

@[card](https://github.com/pome-ta/a-Shell_Rubicon-ObjC_UIKitSamples)

:::message

### 各バージョン情報

```
iOS           : 18.3.1
a-Shell(mini) :  1.15.11
  Python      :  3.11.0
Rubicon-ObjC  :  0.5.0
```

(一応)a-Shell 以外に [Pythonista for iOS](https://omz-software.com/pythonista/index.html) で、挙動確認をしています。
:::

:::message alert

### パッケージ内ファイル編集後の実行について

一度パッケージを読み込み実行。
その後に、パッケージ内のファイルを編集し実行した場合、**変更内容が反映されません** (または、可能性があります)。
そのため、パッケージ内のファイルを編集した後は、**a-Shell を再起動**してからの実行をお勧めします。
:::

# ハンズオン

空の新規ファイルから、順を追って実装していきます。最終的には公開しているリポジトリ[`exampleSFSymbolsViewer.py`](https://github.com/pome-ta/a-Shell_Rubicon-ObjC_UIKitSamples/blob/main/exampleSFSymbolsViewer.py) のコードとなります。


先に、完成予定のコードです。


```python: exampleSFSymbolsViewer.py | 全体
from pathlib import Path
import plistlib

from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method, objc_property
from pyrubicon.objc.runtime import send_super

from rbedge.enumerations import UITableViewStyle
from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')
UITableView = ObjCClass('UITableView')
UITableViewCell = ObjCClass('UITableViewCell')
UIImage = ObjCClass('UIImage')

NSLayoutConstraint = ObjCClass('NSLayoutConstraint')
UIColor = ObjCClass('UIColor')


def get_order_list():
  CoreGlyphs_path = '/System/Library/CoreServices/CoreGlyphs.bundle/'

  symbol_order_path = 'symbol_order.plist'
  symbol_order_bundle = Path(CoreGlyphs_path, symbol_order_path)

  order_list = plistlib.loads(symbol_order_bundle.read_bytes())
  return order_list


class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()
  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.cell_identifier = 'customCell'
    self.all_items = get_order_list()

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title
    self.view.backgroundColor = UIColor.systemBackgroundColor()

    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.registerClass_forCellReuseIdentifier_(UITableViewCell,
                                                       self.cell_identifier)
    sf_tableView.dataSource = self
    sf_tableView.delegate = self

    # --- Layout
    self.view.addSubview_(sf_tableView)
    sf_tableView.translatesAutoresizingMaskIntoConstraints = False
    areaLayoutGuide = self.view.safeAreaLayoutGuide

    NSLayoutConstraint.activateConstraints_([
      sf_tableView.centerXAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerXAnchor),
      sf_tableView.centerYAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerYAnchor),
      sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.widthAnchor, 1.0),
      sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.heightAnchor, 1.0),
    ])

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')

  # --- UITableViewDataSource
  @objc_method
  def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
    return len(self.all_items)

  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)

    symbol_name = self.all_items[indexPath.row]

    content = cell.defaultContentConfiguration()
    content.text = symbol_name
    content.textProperties.numberOfLines = 1
    content.image = UIImage.systemImageNamed_(symbol_name)
    cell.contentConfiguration = content

    return cell

  # --- UITableViewDelegate
  @objc_method
  def tableView_didSelectRowAtIndexPath_(self, tableView, indexPath):
    #tableView.deselectRowAtIndexPath_animated_(indexPath, True)
    select_item = self.all_items[indexPath.row]

    print(f'select:\t{select_item}')


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = SFSymbolsViewController.new()
  _title = NSStringFromClass(SFSymbolsViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```




## まずは、何もしない View を出す

### `UIViewController` で、そのまま

View が出ないと始まらないので、View が出る状態まで持っていきます。
Class `UIViewController` を継承しますが、最初は`UIViewController` で、そのまま出してみましょう。

```python:何もしない View | 全体
from pyrubicon.objc.api import ObjCClass
from rbedge.functions import NSStringFromClass

UIViewController = ObjCClass('UIViewController')

if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = UIViewController.new()
  _title = NSStringFromClass(UIViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```

![image](https://github.com/user-attachments/assets/9eed1ee0-e57c-4aba-aa49-941e799bac46)

`navigationItem.title` をインスタンス生成後に指定しています。`NSStringFromClass` で、Class `UIViewController` より文字列を取得します。

### 継承したクラス`SFSymbolsViewController`

Class `UIViewController` を継承し`SFSymbolsViewController` クラスとします。
今後はこのクラスに実装内容を書いていきます。

```python: 継承 SFSymbolsViewController | 全体
from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method
from pyrubicon.objc.runtime import send_super

from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')


class SFSymbolsViewController(UIViewController):

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = SFSymbolsViewController.new()
  _title = NSStringFromClass(SFSymbolsViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```

#### 継承したので書き換える

継承してクラスを定義するので、`send_super` と`objc_method` を`import` に追加しています。また、View Life Cycle 系のメソッドは必要なメソッドのみ書いていくことにします。

```diff python
from pyrubicon.objc.api import ObjCClass
+ from pyrubicon.objc.api import objc_method
+ from pyrubicon.objc.runtime import send_super

from rbedge.functions import NSStringFromClass
```

表示させるインスタンスを`UIViewController` から`SFSymbolsViewController` に変更しています。

```diff python
+ main_vc = SFSymbolsViewController.new()
- main_vc = UIViewController.new()
+ _title = NSStringFromClass(SFSymbolsViewController)
- _title = NSStringFromClass(UIViewController)
```

#### `navigationItem.title` の指定

`SFSymbolsViewController` インスタンス生成後に、タイトルを指定しない場合。`viewDidLoad` 実行時の`self.navigationItem.title` は`None` となります。
そこで`if` 分岐を使い、タイトルの表示分けができます。
(今回は、インスタンス生成後のタイトルも同じ`NSStringFromClass` を使うので変わりないですが)

他のタイトルにしたい場合は、インスタンス生成後に指定すれば表示されます。

```python
# インスタンス生成後に`title` 指定があるかないかで分岐
self.navigationItem.title = NSStringFromClass(__class__) if (
  title := self.navigationItem.title) is None else title

...

# 今回は、インスタンス生成後に指定するパターンで
_title = NSStringFromClass(SFSymbolsViewController)
main_vc.navigationItem.title = _title
```

また、Class 継承をしたので、`title` を`NSStringFromClass` で指定した場合、出力内容が一部変わります。
連続で実行すると、実行回数ごとに末尾の数値がインクリメントされていきます。

- 初回実行
  ![image](https://github.com/user-attachments/assets/a22b12d3-1846-4c7d-95f7-2d9ad23b1712)

- 2 回目実行
  ![image](https://github.com/user-attachments/assets/2b9aab47-8ec8-4d42-8b23-fcf0fb148de7)

## 何もしない`UITableView` の実装

今回は、SF Symbols の一覧を表示させたいので、[`UITableView`](https://developer.apple.com/documentation/uikit/uitableview?language=objc) を使います。

@[card](https://developer.apple.com/documentation/uikit/uitableview?language=objc)

[`UITableViewController`](https://developer.apple.com/documentation/uikit/uitableviewcontroller?language=objc) を使う方法もあります。
しかし、今回は今後の拡張性も考慮し、`UIViewController` の`view` に`UITableView` を乗せる方針にします。

@[card](https://developer.apple.com/documentation/uikit/uitableviewcontroller?language=objc)

真ん中あるシアン色の矩形が`UITableView` です。
![image](https://github.com/user-attachments/assets/df361ef4-e8ec-4167-bbe6-d8d841abb578)



```python: 何もしない UITableView | 全体
from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method
from pyrubicon.objc.runtime import send_super

from rbedge.enumerations import UITableViewStyle
from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')
UITableView = ObjCClass('UITableView')

NSLayoutConstraint = ObjCClass('NSLayoutConstraint')
UIColor = ObjCClass('UIColor')


class SFSymbolsViewController(UIViewController):

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title

    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.backgroundColor = UIColor.systemCyanColor()

    # --- Layout
    self.view.addSubview_(sf_tableView)
    sf_tableView.translatesAutoresizingMaskIntoConstraints = False
    areaLayoutGuide = self.view.safeAreaLayoutGuide

    NSLayoutConstraint.activateConstraints_([
      sf_tableView.centerXAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerXAnchor),
      sf_tableView.centerYAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerYAnchor),
      sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.widthAnchor, 0.5),
      sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.heightAnchor, 0.5),
    ])

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = UIViewController.new()
  _title = NSStringFromClass(UIViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```

### `initWithFrame` と`style`

`UITableView` のインスタンスを生成するメソッドです。
`style` 指定は、[`rbedge.enumerations`](https://github.com/pome-ta/a-Shell_Rubicon-ObjC_UIKitSamples/blob/main/rbedge/enumerations.py) 内で定義しています(サンプルリポジトリをコピーしている場合)。

@[card](https://developer.apple.com/documentation/uikit/uitableview/init%28frame:style:%29?language=objc)

今回は、`plain` を指定します。

```python
# rbedge にenumerations.py がない場合は
# このクラスを追加してください
class UITableViewStyle:
  plain: int = 0
  grouped: int = 1
  insetGrouped: int = 2
```

@[card](https://developer.apple.com/documentation/uikit/uitableviewstyle?language=objc)
@[card](https://docs.rs/objc2-ui-kit/latest/src/objc2_ui_kit/generated/UITableView.rs.html#19)

もし、`UITableView` の`init` メソッドがわからない場合。

```python: console に出力
pdbr.state(UITableView.alloc())
```

しかし、ものすごい量のメソッドたちが出てくるので、まずはドキュメントを探すのをお勧めします。

### `UIColor` で色付け

何もしない`UITableView` なので、今のところ背面に色をつけて`addSubview_` できているか確認します。
色はどれでもいいので、先ほどの`pdbr.state`で、使える色を見てみます。

```python: console に出力
pdbr.state(UIColor)
```

```結果の一部
...
  "systemBackgroundColor",
  "systemBlackColor",
  "systemBlueColor",
  "systemBrownColor",
  "systemCyanColor",
  "systemDarkBlueColor",
  "systemDarkExtraLightGrayColor",
  "systemDarkExtraLightGrayTintColor",
  "systemDarkGrayColor",
  "systemDarkGrayTintColor",
...
```

一部を抜き出しています、`system〜` あたりは使い勝手がいいと思います。

#### 少し脱線

シアンの色を`UIColor.systemCyanColor()` と呼び出しました。他に`UIColor.cyanColor` でも呼び出せます。

- [`systemCyanColor` | Apple Developer Documentation](https://developer.apple.com/documentation/uikit/uicolor/systemcyan?language=objc)
@[crad](https://developer.apple.com/documentation/uikit/uicolor/systemcyan?language=objc)

- [`cyanColor` | Apple Developer Documentation](https://developer.apple.com/documentation/uikit/uicolor/cyan?language=objc)
@[card](https://developer.apple.com/documentation/uikit/uicolor/cyan?language=objc)


ドキュメントでは、`Type Property` で違いはないのです。
メソッドなのか、プロパティなのか。`system` の方がメソッド呼び出しと考えられます。
しかし、私は毎回忘れるので、とりあえず実行してみて、エラーが出るかどうかで判断しています。


ちなみに、Rubicon-ObjC と同じ作者が [toga](https://github.com/beeware/toga) というものを作っています。
toga の中で`UIColor` は、`declare_class_property` を使いプロパティ呼び出しができるように設定している模様です。


@[card](https://github.com/beeware/toga/blob/74cb4c12b37784bb179d910524746fcf80ccaf79/iOS/src/toga_iOS/libs/uikit.py#L196)

@[card](https://rubicon-objc.readthedocs.io/en/stable/reference/rubicon-objc-api.html#rubicon.objc.api.ObjCClass.declare_class_property)



### View のAuto Layout

View のサイズや位置は普段、Storyboard で設定をします。
a-Shell の場合は、Storyboard を使わないので、コードで設定します。

今回はAuto Layout で設定します。
[`NSLayoutConstraint`](https://developer.apple.com/documentation/uikit/nslayoutconstraint?language=objc) と、[`NSLayoutAnchor`](https://developer.apple.com/documentation/uikit/nslayoutanchor?language=objc) を組み合わせることで簡潔に記述することができます。

@[card](https://techblog.recochoku.jp/7727)


Auto Layout したいView の`translatesAutoresizingMaskIntoConstraints` を`False` にします。
`False` にしないと、Auto Layout の設定はできません。

```python
sf_tableView.translatesAutoresizingMaskIntoConstraints = False
```


基本的に、数値決め打ちは気持ち悪いので、`self.view` (`SFSymbolsViewController` のView) を起点にレイアウトを組みます。
また、今後`sf_tableView` を全画面に表示することを見据え、`self.view` のsafe area を参照の値とします。

@[card](https://developer.apple.com/documentation/uikit/positioning-content-relative-to-the-safe-area?language=objc)


X軸Y軸、幅と高さを`sf_tableView` に指定します。

```python
areaLayoutGuide = self.view.safeAreaLayoutGuide

NSLayoutConstraint.activateConstraints_([
  sf_tableView.centerXAnchor.constraintEqualToAnchor_(
    areaLayoutGuide.centerXAnchor),
  sf_tableView.centerYAnchor.constraintEqualToAnchor_(
    areaLayoutGuide.centerYAnchor),
  sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
    areaLayoutGuide.widthAnchor, 0.5),
  sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
    areaLayoutGuide.heightAnchor, 0.5),
])
```

X軸Y軸は、それぞれの中心点。幅と高さは半分の値で設定しました。

## `UITableView` の要素を出す

配列の要素を`sf_tableView` に表示させます。普段Storyboard で実装していると登場しないメソッドが出てきます。


![image](https://github.com/user-attachments/assets/f5cb7c8c-e19e-4eda-bc59-094160803dff)


```python
from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method, objc_property
from pyrubicon.objc.runtime import send_super

from rbedge.enumerations import UITableViewStyle
from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')
UITableView = ObjCClass('UITableView')
UITableViewCell = ObjCClass('UITableViewCell')

NSLayoutConstraint = ObjCClass('NSLayoutConstraint')
UIColor = ObjCClass('UIColor')


class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()
  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.cell_identifier = 'customCell'
    self.all_items = [
      'ほげ',
      'ふが',
      'ぴよ',
    ]

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title

    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.registerClass_forCellReuseIdentifier_(UITableViewCell,
                                                       self.cell_identifier)
    sf_tableView.dataSource = self

    sf_tableView.backgroundColor = UIColor.systemCyanColor()

    # --- Layout
    self.view.addSubview_(sf_tableView)
    sf_tableView.translatesAutoresizingMaskIntoConstraints = False
    areaLayoutGuide = self.view.safeAreaLayoutGuide

    NSLayoutConstraint.activateConstraints_([
      sf_tableView.centerXAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerXAnchor),
      sf_tableView.centerYAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerYAnchor),
      sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.widthAnchor, 0.5),
      sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.heightAnchor, 0.5),
    ])

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')

  # --- UITableViewDataSource
  @objc_method
  def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
    return len(self.all_items)

  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)
    content = cell.defaultContentConfiguration()
    content.text = self.all_items[indexPath.row]
    cell.contentConfiguration = content
    return cell


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = UIViewController.new()
  _title = NSStringFromClass(UIViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```

:::message
テーブルのスクロールアニメーション中に、close ボタンで閉じるとa-Shell がクラッシュします。
アニメーションを終え、一呼吸置いてから閉じると正常に動作します。
（回避策検討中）
:::

### `objc_property`

Class に独自のプロパティを持たせる場合、`objc_property` で宣言をします。
`objc_property` 宣言しないと、View を閉じた際のメモリ解放がうまく行われません。a-Shell がクラッシュします。

Pythonクラスの`self` のように扱えますが、`objc_property` を使うことにより複雑になるので使用しないようにしています。

複雑さを避けるため:
- シンプルな型
- メソッド内で処理できるよう工夫

といった、方針で実装しています。
`sf_tableView` も`objc_property` 宣言したいところですが、複雑さ回避のため`viewDidLoad` の肥大化とトレードオフとしています。。


```python
from pyrubicon.objc.api import objc_method, objc_property

class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()
  all_items: list = objc_property()
```

今回は、`UITableViewCell` の識別子(`cell_identifier`)と、配列要素(`all_items`) で宣言します。
型は、必須ではありません。自分の備忘として入れています。


@[card](https://rubicon-objc.readthedocs.io/en/stable/how-to/memory-management.html#reference-cycles-in-objective-c)



### セルを登録

`UITableView` は、1つ1つの`UITableViewCell` をまとめて表示します。
その1つの`UITableViewCell` は、事前に識別子を定義し、`UITableView` へ登録する必要があります。



```python
class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.cell_identifier = 'customCell'
    
  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')
    # 中略
    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.registerClass_forCellReuseIdentifier_(UITableViewCell,
                                                       self.cell_identifier)
```

`loadView` メソッド時に、`customCell` という文字列を定義。
`viewDidLoad` メソッドで、`customCell` を識別子としての登録を`UITableViewCell` を使う宣言をしています。

```python
sf_tableView.registerClass_forCellReuseIdentifier_(
  UITableViewCell, self.cell_identifier)
```

### `dataSource` との連携


セルを`UITableView` に反映するため、以下2点が必要です:

- 対応するメソッドの実装
  - Protocol [`UITableViewDataSource`](https://developer.apple.com/documentation/uikit/uitableviewdatasource?language=objc)
- `sf_tableView` の`dataSource` へ通知



今回、最小限のメソッドで実装します。「必須」のメソッドです:

- [`tableView:numberOfRowsInSection:` | Apple Developer Documentation](https://developer.apple.com/documentation/uikit/uitableviewdatasource/tableview%28_:numberofrowsinsection:%29?language=objc)
  - 表示させるセルの総数の提示
    - (正確には、section のrow の数ですが、詳細はドキュメント参照)
- [`tableView:cellForRowAtIndexPath:` | Apple Developer Documentation](https://developer.apple.com/documentation/uikit/uitableviewdatasource/tableview%28_:cellforrowat:%29?language=objc)
  - 各セルごとの設定

```python
class SFSymbolsViewController(UIViewController):

  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.all_items = [
      'ほげ',
      'ふが',
      'ぴよ',
    ]

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')
    # 中略
    
    sf_tableView.dataSource = self

  # --- UITableViewDataSource
  @objc_method
  def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
    return len(self.all_items)

  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)
    content = cell.defaultContentConfiguration()
    content.text = self.all_items[indexPath.row]
    cell.contentConfiguration = content
    return cell


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = UIViewController.new()
  _title = NSStringFromClass(UIViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```


#### `tableView_numberOfRowsInSection_` メソッド

表示させるセルの総数を整数値で返します。

一部の引数や返り値に型ヒントを付ける必要があり、Rubicon-ObjC のドキュメント[Type annotations](https://rubicon-objc.readthedocs.io/en/stable/how-to/type-mapping.html#type-annotations) に説明があります。
Rubicon-ObjC のオブジェクトには、型ヒントは不要です。

@[card](https://rubicon-objc.readthedocs.io/en/stable/how-to/type-mapping.html#type-annotations)


```python
@objc_method
def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
  return len(self.all_items)
```

引数`section` は、整数`int` 。返り値もPython の整数型なので`int` と指定します。


@[card](https://developer.apple.com/documentation/uikit/uitableviewdatasource/tableview%28_:numberofrowsinsection:%29?language=objc)

#### `tableView_cellForRowAtIndexPath_` メソッド

各セルごとの要素を設定して返します。
返り値も、Rubicon-ObjC のオブジェクトになるので、型ヒントは不要です。
型ヒントを入れるのであれば、`ObjCInstance` あたりでしょうか。エラーが出ないので、詳しくは追ってません。


```python
@objc_method
def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
  cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
    self.cell_identifier, indexPath)
  content = cell.defaultContentConfiguration()
  content.text = self.all_items[indexPath.row]
  cell.contentConfiguration = content
  return cell
```

`dequeueReusableCellWithIdentifier` で、識別子セルを呼び出します。
`indexPath`([`NSIndexPath`](https://developer.apple.com/documentation/foundation/nsindexpath?language=objc)) の、インデックス情報から、配列要素を取り出します。

今回は、セルに文字列を反映する簡単な実装です。


@[card](https://developer.apple.com/documentation/uikit/uitableviewdatasource/tableview%28_:cellforrowat:%29?language=objc)
@[card](https://developer.apple.com/documentation/uikit/uitableviewcell/defaultcontentconfiguration?language=objc)

#### `sf_tableView.dataSource = self`

Class `SFSymbolsViewController` に`UITableViewDataSource` Protocol 要素のメソッドを追加しました。
そのメソッドを`sf_tableView.dataSource` と、するために`= self` としています。
`= self` だと全てのメソッドとイメージしてしまいますが、対応するメソッドのみ認識するようです。

これにより、`sf_tableView` にセルの要素が反映されます。


## SF Symbols 情報を取得する

View の表示として、配列要素を`UITableView` に反映ができました。配列要素は、Python の`list` 形式で問題なさそうです。
そこでここからは、仮の配列要素を、実際に使うSF Symbols 情報に変えていきます。
View の表示は一旦お休みです。


実は、SF Symbols を得るのは簡単です。どこかのサーバーにアクセスしたり、ハードコードで写経する必要はありません。

お手持ちのiPhone やiPad の中にあります。

```python
from pathlib import Path
import plistlib


def get_order_list():
  CoreGlyphs_path = '/System/Library/CoreServices/CoreGlyphs.bundle/'

  symbol_order_path = 'symbol_order.plist'
  symbol_order_bundle = Path(CoreGlyphs_path, symbol_order_path)

  order_list = plistlib.loads(symbol_order_bundle.read_bytes())
  return order_list
```


標準ライブラリ`pathlib` で、端末内部のディレクトリデータにアクセスします。
`CoreGlyphs.bundle/` 内にSF Symbols 情報の`.plist` ファイルがあります。
今回だと、`symbol_order.plist` の要素が扱いやすそうなので、こちらから情報を取得します。
取得には、標準ライブラリの`plistlib` を使います。


なお、他の`.plist` ファイルは、dump したものを以下のリポジトリにまとめています。

@[card](https://github.com/pome-ta/pysta-icons/tree/master/sandbox/dumps)


`plistlib` なんて初めてつかいました。
@[card](https://docs.python.org/ja/3.11/library/plistlib.html)



### `symbol_order.plist` の中身

```python
print(get_order_list())
```

とすれば、確認できます。しかし、7000以上あるのでdump データを確認しながら進めます。


@[card](https://github.com/pome-ta/pysta-icons/blob/master/sandbox/dumps/symbol_order.plist.json)


以下のように文字列の配列が確認できます:

```
[
  "square.and.arrow.up",
  "square.and.arrow.up.fill",
  "square.and.arrow.up.circle",
  "square.and.arrow.up.circle.fill",
  "square.and.arrow.up.badge.clock",
  "square.and.arrow.up.badge.clock.fill",
  "square.and.arrow.up.trianglebadge.exclamationmark",
  "square.and.arrow.up.trianglebadge.exclamationmark.fill",
  "square.and.arrow.down",
  "square.and.arrow.down.fill",
  ...
  "48.square.hi",
  "48.square.fill.hi",
  "49.circle.hi",
  "49.circle.fill.hi",
  "49.square.hi",
  "49.square.fill.hi",
  "50.circle.hi",
  "50.circle.fill.hi",
  "50.square.hi",
  "50.square.fill.hi",
  "apple.logo"
]
```

文字列が、それぞれSF Symbols の名前となります。


## 各セルへSF Symbols を表示

SF Symbols の情報を関数`get_order_list` により取得できるようになりました。
次は、各セルにSF Symbols のアイコンと名前を反映させます。
各SF Symbols の名前がわかれば、`UIImage` より簡単に取得できます。


![image](https://github.com/user-attachments/assets/c3aa117a-de13-4fe6-b7ce-d65f6c4e862e)


```python
from pathlib import Path
import plistlib

from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method, objc_property
from pyrubicon.objc.runtime import send_super

from rbedge.enumerations import UITableViewStyle
from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')
UITableView = ObjCClass('UITableView')
UITableViewCell = ObjCClass('UITableViewCell')
UIImage = ObjCClass('UIImage')

NSLayoutConstraint = ObjCClass('NSLayoutConstraint')
UIColor = ObjCClass('UIColor')


def get_order_list():
  CoreGlyphs_path = '/System/Library/CoreServices/CoreGlyphs.bundle/'

  symbol_order_path = 'symbol_order.plist'
  symbol_order_bundle = Path(CoreGlyphs_path, symbol_order_path)

  order_list = plistlib.loads(symbol_order_bundle.read_bytes())
  return order_list


class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()
  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.cell_identifier = 'customCell'
    self.all_items = get_order_list()

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title

    self.view.backgroundColor = UIColor.systemDarkPinkColor()

    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.registerClass_forCellReuseIdentifier_(UITableViewCell,
                                                       self.cell_identifier)
    sf_tableView.dataSource = self

    sf_tableView.backgroundColor = UIColor.systemCyanColor()

    # --- Layout
    self.view.addSubview_(sf_tableView)
    sf_tableView.translatesAutoresizingMaskIntoConstraints = False
    areaLayoutGuide = self.view.safeAreaLayoutGuide

    NSLayoutConstraint.activateConstraints_([
      sf_tableView.centerXAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerXAnchor),
      sf_tableView.centerYAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerYAnchor),
      sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.widthAnchor, 0.5),
      sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.heightAnchor, 0.5),
    ])

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')

  # --- UITableViewDataSource
  @objc_method
  def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
    return len(self.all_items)

  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)

    symbol_name = self.all_items[indexPath.row]

    content = cell.defaultContentConfiguration()
    content.text = symbol_name
    content.image = UIImage.systemImageNamed_(symbol_name)
    cell.contentConfiguration = content

    return cell


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = UIViewController.new()
  _title = NSStringFromClass(UIViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```

背面色を`systemDarkPinkColor` にしています。
`sf_tableView` との境界と、スクロール挙動時のナビゲーション透過の確認用です。


### `systemImageNamed_` メソッド


[`UIImage`](https://developer.apple.com/documentation/uikit/uiimage?language=objc) の[`systemImageNamed:`](https://developer.apple.com/documentation/uikit/uiimage/init%28systemname:%29?language=objc) へ、文字列でSF Symbols の名前を引数に渡せば取得できます。


@[card](https://developer.apple.com/documentation/uikit/uiimage/init%28systemname:%29?language=objc)
@[card](https://developer.apple.com/documentation/uikit/uiimage?language=objc)

```python
UIImage = ObjCClass('UIImage')


class SFSymbolsViewController(UIViewController):

  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.all_items = get_order_list()


  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # 背景色追加
    self.view.backgroundColor = UIColor.systemDarkPinkColor()


  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)

    symbol_name = self.all_items[indexPath.row]

    content = cell.defaultContentConfiguration()
    content.text = symbol_name
    content.image = UIImage.systemImageNamed_(symbol_name)
    cell.contentConfiguration = content

    return cell
```

配列`self.all_items` より、インデックスで該当の情報を取得します。
そして、[`defaultContentConfiguration`](https://developer.apple.com/documentation/uikit/uitableviewcell/defaultcontentconfiguration?language=objc) の、`.image` へ定義すれば反映されます。


## 仕上げに微調整

仕上げに:

- 見た目の整え
  - `sf_tableView` の全画面表示
  - セルの文字列を1行で表示
- 押したセルのアイコン名を出力
- 不要な処理の整理
  - `backgroundColor`

をして、完成とします。


 


![image](https://github.com/user-attachments/assets/9bd5ebab-2e22-4f66-be66-fb31da505efb)


```python
from pathlib import Path
import plistlib

from pyrubicon.objc.api import ObjCClass
from pyrubicon.objc.api import objc_method, objc_property
from pyrubicon.objc.runtime import send_super

from rbedge.enumerations import UITableViewStyle
from rbedge.functions import NSStringFromClass
from rbedge import pdbr

UIViewController = ObjCClass('UIViewController')
UITableView = ObjCClass('UITableView')
UITableViewCell = ObjCClass('UITableViewCell')
UIImage = ObjCClass('UIImage')

NSLayoutConstraint = ObjCClass('NSLayoutConstraint')
UIColor = ObjCClass('UIColor')


def get_order_list():
  CoreGlyphs_path = '/System/Library/CoreServices/CoreGlyphs.bundle/'

  symbol_order_path = 'symbol_order.plist'
  symbol_order_bundle = Path(CoreGlyphs_path, symbol_order_path)

  order_list = plistlib.loads(symbol_order_bundle.read_bytes())
  return order_list


class SFSymbolsViewController(UIViewController):

  cell_identifier: str = objc_property()
  all_items: list = objc_property()

  @objc_method
  def loadView(self):
    send_super(__class__, self, 'loadView')
    self.cell_identifier = 'customCell'
    self.all_items = get_order_list()

  @objc_method
  def viewDidLoad(self):
    send_super(__class__, self, 'viewDidLoad')

    # --- Navigation
    self.navigationItem.title = NSStringFromClass(__class__) if (
      title := self.navigationItem.title) is None else title
    self.view.backgroundColor = UIColor.systemBackgroundColor()

    # --- Table
    sf_tableView = UITableView.alloc().initWithFrame_style_(
      self.view.bounds, UITableViewStyle.plain)
    sf_tableView.registerClass_forCellReuseIdentifier_(UITableViewCell,
                                                       self.cell_identifier)
    sf_tableView.dataSource = self
    sf_tableView.delegate = self

    # --- Layout
    self.view.addSubview_(sf_tableView)
    sf_tableView.translatesAutoresizingMaskIntoConstraints = False
    areaLayoutGuide = self.view.safeAreaLayoutGuide

    NSLayoutConstraint.activateConstraints_([
      sf_tableView.centerXAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerXAnchor),
      sf_tableView.centerYAnchor.constraintEqualToAnchor_(
        areaLayoutGuide.centerYAnchor),
      sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.widthAnchor, 1.0),
      sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
        areaLayoutGuide.heightAnchor, 1.0),
    ])

  @objc_method
  def didReceiveMemoryWarning(self):
    send_super(__class__, self, 'didReceiveMemoryWarning')
    print(f'\t{NSStringFromClass(__class__)}: didReceiveMemoryWarning')

  # --- UITableViewDataSource
  @objc_method
  def tableView_numberOfRowsInSection_(self, tableView, section: int) -> int:
    return len(self.all_items)

  @objc_method
  def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
    cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
      self.cell_identifier, indexPath)

    symbol_name = self.all_items[indexPath.row]

    content = cell.defaultContentConfiguration()
    content.text = symbol_name
    content.textProperties.numberOfLines = 1
    content.image = UIImage.systemImageNamed_(symbol_name)
    cell.contentConfiguration = content

    return cell

  # --- UITableViewDelegate
  @objc_method
  def tableView_didSelectRowAtIndexPath_(self, tableView, indexPath):
    #tableView.deselectRowAtIndexPath_animated_(indexPath, True)
    select_item = self.all_items[indexPath.row]

    print(f'select:\t{select_item}')


if __name__ == '__main__':
  from rbedge.app import App
  from rbedge.enumerations import UIModalPresentationStyle

  main_vc = SFSymbolsViewController.new()
  _title = NSStringFromClass(SFSymbolsViewController)
  main_vc.navigationItem.title = _title

  presentation_style = UIModalPresentationStyle.fullScreen

  app = App(main_vc, presentation_style)
  app.present()
```



### `sf_tableView` の全画面表示

`viewDidLoad` で`NSLayoutConstraint` を使って位置とサイズを指定していました。

`widthAnchor` と`heightAnchor` の値を`0.5` から`1.0` に変更するだけです。


```python
NSLayoutConstraint.activateConstraints_([
  sf_tableView.centerXAnchor.constraintEqualToAnchor_(
    areaLayoutGuide.centerXAnchor),
  sf_tableView.centerYAnchor.constraintEqualToAnchor_(
    areaLayoutGuide.centerYAnchor),
  sf_tableView.widthAnchor.constraintEqualToAnchor_multiplier_(
    areaLayoutGuide.widthAnchor, 1.0),  # 0.5 -> 1.0
  sf_tableView.heightAnchor.constraintEqualToAnchor_multiplier_(
    areaLayoutGuide.heightAnchor, 1.0),  # 0.5 -> 1.0
])
```

### セルの文字列を1行で表示

各SF Symbols の名前が、短いのと長いのが極端です。セル内が2行となったりして、統一感がありません。
そこで、セル幅を越えた文字列を`...` と省略することにします。

```python
@objc_method
def tableView_cellForRowAtIndexPath_(self, tableView, indexPath):
  cell = tableView.dequeueReusableCellWithIdentifier_forIndexPath_(
    self.cell_identifier, indexPath)

  symbol_name = self.all_items[indexPath.row]

  content = cell.defaultContentConfiguration()
  content.text = symbol_name
  content.textProperties.numberOfLines = 1
  content.image = UIImage.systemImageNamed_(symbol_name)
  cell.contentConfiguration = content

  return cell
```

`textProperties.numberOfLines = 1` の部分です。追加します。

@[card](https://developer.apple.com/documentation/uikit/uilistcontenttextproperties/numberoflines)



### 押したセルのアイコン名を出力

`UITableViewDelegate` Protocol を使って、セルがタップされた時の挙動を、指定します。


```python
# --- UITableViewDelegate
@objc_method
def tableView_didSelectRowAtIndexPath_(self, tableView, indexPath):
  #tableView.deselectRowAtIndexPath_animated_(indexPath, True)
  select_item = self.all_items[indexPath.row]

  print(f'select:\t{select_item}')
```

タップしたセルのアイコン名をconsole に出力します。


コメントアウトしている`deselectRowAtIndexPath_` は、以下を参照してください。
タップ時のハイライト挙動です。
@[card](https://qiita.com/trsxxii/items/8f71ca67da4c6f4b78d2)


また、`UITableViewDelegate` を使うことになったので:

```python
sf_tableView.dataSource = self
sf_tableView.delegate = self
```

と、`dataSource` と同様に、`delegate` へも`self` とします。


### `backgroundColor` 設定

確認用の色でガチャガチャしているので:

```python
self.view.backgroundColor = UIColor.systemBackgroundColor()
```

端末の外観設定がライトかダークにより背景色を変更してくれます。




# おわりに

大体120行ほどで、実装ができました。
今回は、テーブルに一覧を表示する簡単なアプリでしたが、ここから独自に実装をして改良してみてください。

例えば:

- プレビューの表示
- 一覧の検索用のバーを追加
- clipboard にアイコン名をコピー


他のアプリ制作時に、SF Symbols をアイコンを使う場面でのリファレンスとしても機能しそうですね。


Rubicon-ObjC の作者が、[briefcase](https://github.com/beeware/briefcase) というライブラリを制作しており、これを使うとストアへも公開できるとか。
私は、まだ検証していませんが。
@[card](https://github.com/beeware/briefcase)



実装が面倒でも、コードをコピペして実行。View を出して閉じるだけでも普段と違う端末の遊びをしているみたいで楽しいですよ。


私のリポジトリやX など、フィードバックもらえると嬉しいので、お気軽に声かけてください。

